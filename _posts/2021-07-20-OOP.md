---
title: 'OOP란?'
tags: [TIL, JavaScript, CS]
style: fill
color: danger
description: '객체 지향 프로그래밍은 컴퓨터 프로그래밍 패러다임중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.'
---

# OOP(Object Oriented Programing)란?

- 객체 지향 프로그래밍은 컴퓨터 프로그래밍 패러다임중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.
- 프로그램 설계 철학입니다.
- 모든 것은 '객체'로 그룹화됩니다.
- 4가지 주요 개념을 통해 재사용성을 얻을 수 있습니다.

## 객체 지향 프로그래밍 장단점

**장점**

- 코드 재사용이 용이합니다.
  남이 만든 클래스를 가져와서 이용할 수 있고 상속을 통해 확장해서 사용할 수 있습니다.
- 유지보수가 쉽습니다.
  절차 지향 프로그래밍에서는 코드를 수정해야할 때 일일이 찾아 수정해야하는 반면 객체 지향 프로그래밍에서는 수정해야 할 부분이 클래스 내부에 변수혹은 메서드로 있기 때문에 해당 부분만 수정하면 됩니다.
- 대형 프로젝트에 적합합니다.
  클래스단위로 모듈화시켜서 개발할 수 있으므로 대형 프로젝트처럼 여러명, 여러회사에서 개발이 필요할 시 업무 부담하기 쉽습니다.

**단점**

- 처리속도가 상대적으로 느립니다.
- 객체가 많으면 용량이 커질 수 있습니다.
- 설계시 많은 시간과 노력이 필요합니다.

## 클래스와 인스턴스(객체)

**클래스**

- 클래스는 일종의 원형(original form)으로, 객체를 생성하기 위한 아이디어나 청사진입니다.
- 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성과 행위를 변수와 메서드로 정의한 것입니다.

**인스턴스(객체)**

- 인스턴스는 클래스의 사례(instance object)입니다.
- 클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터입니다.
  ![](https://images.velog.io/images/blackdavil01/post/d80bfb3a-6cbf-47e3-a4eb-7e55d3e47000/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-20%2016-28-29.png)

**클래스와 인스턴스는 붕어빵과 붕어빵을 찍는 틀로 표현하면 클래스는 설계도(만들어져있는 틀)이고 인스턴스는 설계도대로 만들어진 결과물(붕어빵)입니다.**

## OOP의 특징

### Encapsulation(캡슐화)

- **데이터와 기능을 하나의 단위로 묶는 것**
  캡슐화는 속성과 메소드를 따로 정의하는 것이 아닌, 하나의 객체 안에 넣어서 묶는 것입니다. 속성과 메소드 들이 느슨하게 결합됩니다.
- **느슨한 결합(Loose Coupling)에 유리:** 언제든 구현을 수정할 수 있습니다.
  느슨한 결합은 코드 실행 순서에 따라 절차적으로 코드를 작성하는 것이 아니라, 코드가 상징하는 실제 모습과 닮게 코드를 모아 결합하는 것을 의미합니다. 코드만 보고도 인스턴스 객체의 기능을 상상할 수 있게 작성하는 것이 느슨한 결합을 추구하는 코드 작성법입니다.
- **은닉(hiding):** 구현은 숨기고, 동작은 노출시킴
  캡슐화라는 개념에는 '은닉화'의 특징도 포함하고 있는데, 은닉화는 내부 데이터나 내부 구현이 외부로 노출되지 않도록 만드는 것입니다. 따라서, 디테일한 구현이나 데이터는 숨기고, 객체 외부에서 필요한 메소드만 노출시켜야 합니다. 은닉화의 특징을 살려서 코드를 작성하면 객체 내 메소드의 구현만 수정하고, 노출된 메소드를 사용하는 코드 흐름은 바뀌지 않도록 만들 수 있습니다. 반면 절차적 코드의 경우 데이터의 형태가 바뀔때에 코드의 흐름에 큰 영향을 미치게 되어 유지보수가 어렵습니다. 그래서 더 엄격한 클래스는 속성의 직접적인 접근을 막고, 설정하는 함수(setter), 불러오는 함수(getter)를 철저하게 나누기도 합니다.

### Abstraction(추상화)

![](https://images.velog.io/images/blackdavil01/post/55db95fb-193e-490f-b450-7f8ecb654e64/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-20%2016-36-18.png)
추상화는 내부 구현은 아주 복잡한데, 실제로 노출되는 부분은 단순하게 만든다는 개념입니다. 예를 들어 전화라는 객체가 있다면, 그 안에는 스피커와 마이크가 존재하고, 서킷 보드 등이 존재하는 등 내부 구현이 되어 있을 것입니다. 그러나 실제로 우리가 사용할 때에는, 이러한 존재에 대해서는 생각하지 않고, 단순히 수화기를 들고 버튼을 눌러서 해결하는 것으로 인터페이스를 단순화할 수 있습니다.
이러한 추상화를 통해 인터페이스가 단순해집니다. 너무 많은 기능들이 노출되지 않은 덕분에 예기치 못한 사용상의 변화가 일어나지 않도록 만들 수 있습니다. 추상화는 캡슐화와 비교해서 종종 헷갈려하는 개념 중 하나입니다.
캡슐화가 코드나 데이터의 은닉에 포커스가 맞춰져있다면, 추상화는 클래스를 사용하는 사람이 필요하지 않은 메소드 등을 노출시키지 않고, 단순한 이름으로 정의하는 것에 포커스가 맞춰져 있습니다. 클래스 정의 시, 메소드와 속성만 정의한 것을 인터페이스라고 부릅니다. 이것이 추상화의 본질입니다.

### Inheritance(상속)

![](https://images.velog.io/images/blackdavil01/post/402c653d-8aa0-470a-a304-fe15564e8513/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-20%2016-41-26.png)
상속은 부모 크래스의 특징을 자식 클래스가 물려받는 것입니다. 즉 기본클래스(base class)의 특징을 파생 클래스(derive class)가 상속받는다로 표현할 수 있습니다.
예를 들어, 사람(Human)이라는 클래스가 있다고 가정해봅시다. 사람은 기본적으로 이름과, 성별, 나이와 같은 속성, 그리고 먹다, 자다 등과 같은 메소드가 있다고 볼 수 있습니다. 추가적으로 학생(Student)이라는 클래스를 작성할 때, 앞서 사람(Human)클래스의 속성과 메소드를 재구현한다면 비효율적일 것입니다. 학생의 본질은 결국 사람이므로, 상속을 이용하여 학생(Student)클래스는 사람(Human)클래스를 상속받을 수 있습니다. 학생은 추가적으로 학습 내용, 공부하다와 같은 속성/메소드를 추가할 뿐인거죠.

### Polymorphism(다형성)

![](https://images.velog.io/images/blackdavil01/post/c486a7dd-6bcd-4124-817f-a0bed3829dca/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-20%2016-44-49.png)
Polymorphism이라는 단어의 poly는 '많은', 그리고 morph는 '형태'라는 뜻을 가지고 있습니다. 즉 '다양한 형태'를 가질 수 있다는 말이 됩니다.
'말하다'라는 동작의 본질은 '입으로 소리를 내다'를 의미합니다. 그러나, 각기 다른 동물들이 '말할때' 제각각의 소리를 내는 것처럼, 객체 역시 똑같은 메소드라 하더라도, 다른 방식으로 구현될 수 있습니다.
만일 언어 자체에서 다형성을 제공하지 않는다면, 기본(부모)클래스에 종류별로 분기를 시켜서 하나하나 다르게 만들어야 할 것입니다. 또는 각각의 자식 클래스의 별도의 각기 다른 render함수를 만들 수도 있겠지만, 엘리먼트라는 클래스의 본질상 '화면에 뿌린다'(render)는 개념은 부모가 갖고 있는 것이 합리적입니다.

### 정리

- **캡슐화**: 코드가 복잡하지 않게 만들고, 재사용성을 높입니다.
- **추상화**: 마찬가지로 코드가 복잡하지 않게 만들고, 단순화된 사용으로 인해 변화에 대한 영향을 최소화합니다.
- **상속**: 불필요한 코드를 줄여 재사용성을 높입니다.
- **다형성**: 하나의 변수명,함수명 등이 상황에 따라 다른 의미로 해석될 수 있습니다. 즉, 오버라이딩, 오버로딩이 가능합니다.

> **오버라이딩:** 부모클래스의 메서드와 같은 이름, 매개변수를 재정의 하는 것
> **오버로딩:** 같은 이름의 함수를 여러개 정의하고, 매개변수의 타입과 개수를 다르게 하여 매개변수에 따라 다르게 호출할 수 있게 하는 것
