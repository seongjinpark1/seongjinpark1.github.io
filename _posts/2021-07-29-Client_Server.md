---
title: '클라이언트-서버'
excerpt: '클라이언트 서버 아키텍처, URL&URI, IP&PORT, Domain&DNS'

categories:
    - TIL
tags:
    - TIL
    - JavaScript
    - NetWork
    - Client_Server
toc: true
toc_sticky: true
last_modified_at: 2021-07-29
---

# 클라이언트 서버 아키텍처

## 2-Tier Architecture

![](https://images.velog.io/images/blackdavil01/post/f1690ed3-df69-4b1b-bd1a-da5afd407774/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-29%2023-02-01.png)
인터넷 연결이 없으면 왜 쇼핑몰 앱이 작동되지 않을까요? 왜냐하면 상품 정보를 인터넷 어딘가에 존재하는 서버로부터 받아와야 하기 때문입니다.
상품 젖ㅇ보같은 리소스가 존재하는 곳과, 리소스를 사용하는 앱을 분리시킨 것을 2티어 아키텍처 또는 클라이언트-서버 아키텍처라고 부릅니다.
리소스를 사용하는 앱이 "클라이언트" 리소스가 제공하는 곳은 "서버"라고 부릅니다.
상품정보는 서버에서 다루고있고 클라이언트는 단지 상품 정보를 조회할 뿐입니다.
즉, 리소스가 존재하는 곳과 리소스를 사용하는 앱을 분리시킨 것을 2-tier 아키텍처라고 부릅니다.

## 3-Tier Architecture

![](https://images.velog.io/images/blackdavil01/post/ae16dcb6-b6cb-488e-aad8-e873c31f979b/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-29%2023-02-48.png)
사실, 보통 서버는 리소스를 전달해 줄뿐, 리소스를 저장하는 공간은 데이터베이스라는 창고에 둡니다.
이처럼 클라이언트 - 서버 아키텍처에 데이터베이스가 추가된 형태를 3-tier 아키텍처라고 부릅니다.

## 클라이언트와 서버 종류

**클라이언트**: 클라이언트는 보통 플랫폼에 따라 구분됩니다. 브라우저를 통해 주로 이용하는 웹플랫폼에서의 클라이언트는 웹사이트 또는 웹 앱이라고 부릅니다. IOS나 안드로이드와 같은 스마트폰/태블릿 플랫폼, 그리고 윈도우 같은 데스크탑 플랫폼에서 이용하는 앱 역시 클라이언트가 될 수 있습니다.
**서버**: 서버는 무엇을 하느냐에 따라 종류가 달라집니다. 파일 서버는 파일을 제공하는 앱, 웹 서버는 웹사이트에서 필요로 하는 정보들을 제공하는 앱, 메일 서버는 메일을 주고 받을 수 있도록 도와주느 앱입니다. 데이터베이스도 데이터 제공자로서 일하므로 일종의 서버라고 볼 수 있습니다.

# 클라이언트-서버 통신과 API

> 클라이언트와 서버 간의 통신은 요청과 응답을오 구성됩니다. 요청이 있어야만 응답이 옵니다.
> 클라이언트-서버 아키텍처에서는 서버 마음대로 클라이언트에 리소스를 전달하지 않습니다.

## 프로토콜(Protocol)

프로토콜은 통신 규약, 즉 약속입니다. 카페를 예로 들면 손님이 주문을 받는 사람에게 대뜸 찾아가, 외계어로 주문을 할 수 없듯, 주문을 하기 위해서는 꼭 지켜야 하는 약속이 몇가지 존재합니다.

-   **웹 애플리케이션 프로토콜:HTTP**
    ![](https://images.velog.io/images/blackdavil01/post/040247c3-8b21-412f-8b10-fc9504be4f3a/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-29%2023-09-12.png)
    웹 애플리케이션 아키텍처에서는 클라이언트와 서버가 서로 HTTP라는 프로토콜을 이용해서 서로 대화를 나눕니다. HTTP를 이용해서 주고받는 메시지는 'HTTP 메시지'라고 부릅니다.

-   **주요 프로토콜 OSI 7 Layers**
    ![](https://images.velog.io/images/blackdavil01/post/5b1f7fdb-6697-4ecd-8a24-e27f53bd8725/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-29%2023-12-18.png)

## API(Application Programming Interface)

컴퓨터에게 요청할 때에는 ,정확한 주문 방법을 따라 요청해야 합니다. 그런데 우리는 서버가 어떻게 구성 되어 있는지 알 방법이 없습니다. 우리가 서버 코드를 직접 짠 사람도 아닌데, 어떻게 클라이언트는 자원을 확인할 수 있을까요?
이에 대한 정답이 바로 API입니다.
서버는 클라이언트에게 리소스를 잘 활용할 수 있도록 인터페이스를 제공해줘야합니다.
API는 앱이 요청할 수 있고, 프로그래밍 가능한 인터페이스입니다.
API는 메뉴판과도 같습니다. 카페 메뉴판은 해당 카페에서 주문 가능한 메뉴를 안내해줍니다. 클라이언트가 엉뚱한 메뉴를 시키지 않도록 합니다.
마찬가지고 서버는 리소스 전달을 위한 메뉴판, 즉 API문서를 작성해야 클라이언트가 이를 활용할 수 있습니다.
보통 인터넷에 있는 데이터를 요청할 때에는 HTTP프로토콜을 사용하며, 주소(URL, URL)를 통해 접근 할 수 있습니다.

## URL과 URI

![](https://images.velog.io/images/blackdavil01/post/564fb395-37cb-43d0-bd30-73410dd7140e/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-29%2023-19-46.png)
**URL**: URL은 Uniform Resource Locator의 줄임말로, 네트워크 상에서 웹 페이지, 이미지, 동영상 등의 파일이 위치한 정보를 나타냅니다. URL은 scheme, hosts, url-path로 구분할 수 있습니다. 가장 먼저 작성하는 scheme은 통신 방식(프로토콜)을 결정합니다. 일반적인 웹 브라우저에서는 http(s)를 사용합니다. hosts는 웹 서버의 이름이나 도메인, IP를 사용하며 주소를 나타냅니다. url-path는 웹 서버에서 지정한 루트 디렉토리부터 시작하여 웹 페이지, 이미지, 동영상 등이 위치한 경로와 파일명을 나타냅니다.

**URI**: URI는 (Uniform Resource Identifier)의 줄임말로, 일반적으로 URL의 기본 요소인 scheme, hosts, url-path에 더해 query, bookmark를 포함합니다. query는 웹 서버에 보내는 추가적인 질문입니다. http://www.google.com:80/search?q=JavaScript 를 브라우저의 검색창에 입력하면, 구글에서 JavaScript를 검색한 결과가 나타납니다.
브라우저의 검색창을 클릭하면 나타나는 주소가 URI입니다. URI는 URL을 포함하는 상위개념입니다. 따라서 URL은 URL다 는 참이고 URI는 url이다는 거짓입니다.

| 부분                             | 명칭     | 설명                                                                                |
| -------------------------------- | -------- | ----------------------------------------------------------------------------------- |
| file://, http://, https://       | scheme   | 통신 프로토콜                                                                       |
| 127.0.0.1, www.google.com        | hosts    | 웹 페이지, 이미지, 동영상 등의 파일이 위치한 웹 서버, 도메인 또는 IP                |
| :80, :443, :3000                 | port     | 웹 서버에 접속하기 위한 통로                                                        |
| /search, /Users/username/Desktop | url-path | 웹 서버의 루트 디렉토리로부터 웹 페이지, 이미지, 동영상 등의 파일이 위치까지의 경로 |
| q=JavaScript                     | query    | 웹 서버에 전달하는 추가 질문                                                        |

## IP와 PORT

-   **IP address**: IP는 Internet Protocol의 줄임말로, 인터넷상에서 사용하는 주소체계를 의미합니다. 인터넷에 연결된 모든 PC는 IP 주소체계를 따라 네 덩이의 숫자로 구분됩니다. 이렇게 네 덩이의 숫자로 구분된 IP주소체계를 IPv4라고 합니다.
    IPv4는 Internet Protocol version 4의 줄임말로, IP 주소체계의 네 번째 버전을 뜻합니다.
    IPv4는 각 덩어리마다 0부터 255까지 나타낼 수 있습니다. 이 시스템을 따르면, 2^(32)인 약 43억 개의 IP 주소를 표현할 수 있습니다. 그 중에서 몇 가지는 이미 용도가 정해져 있습니다.

    > localhost, 127.0.0.1 : 현재 사용 중인 로컬 PC를 지칭합니다.
    > 0.0.0.0, 255.255.255.255 : broadcast address, 로컬 네트워크에 접속된 모든 장치와 소통하는 주소입니다. 서버에서 접근 가능 IP 주소를 broadcast address 로 지정하면, 모든 기기에서 서버에 접근할 수 있습니다.

-   **PORT**: 터미널에서 리액트를 실행하면 나타나는 화면에는, 로컬 PC의 IP 주소인 127.0.0.1 뒤에 :3000과 같은 숫자가 표현됩니다. 이 숫자는 IP 주소가 가리키는 PC에 접속할 수 있는 통로(채널)을 의미합니다. 리액트를 실행했을 때에는 로컬 PC의 IP 주소로 접근하여, 3000번의 통로를 통해 실행 중인 리액트를 확인할 수 있습니다. 이미 사용 중인 포트는 중복해서 사용할 수 없습니다. 만약 다른 프로그램에서 3000번 포트를 사용 중이라면, 다음과 같이 다른 포트 번호로 리액트가 실행됩니다.
    `localhost:3001`
    포트 번호는 0~ 65,535 까지 사용할 수 있습니다. 그 중에서 0 ~ 1024번 까지의 포트 번호는 주요 통신을 위한 규약에 따라 이미 정해져 있습니다. 그중에서 반드시 알아야 할 잘 알려진 포트 번호는 다음과 같습니다.
    > 22 : SSH
    > 80 : HTTP
    > 443: HTTPS

## 도메인과 DNS

-   **Domain name**: 웹 브라우저를 통해 특정 사이트에 진입을 할 때, IP 주소를 대신하여 사용하는 주소가 있습니다. 만약 IP 주소가 지번 또는 도로명 주소라면, 도메인 이름은 해당 주소에 위치한 상호로 볼 수 있습니다. 도메인 이름을 이용하면, 한눈에 파악하기 힘든 IP 주소를 보다 분명하게 나타낼 수 있습니다.
    다음과 같이, 터미널에서 도메인 이름을 통해 IP 주소를 확인하는 명령어 nslookup으로 codestates.com 의 IP 주소를 확인할 수 있습니다.
    ![](https://images.velog.io/images/blackdavil01/post/33069d51-56e6-4a7d-9752-5894b410ad23/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-29%2023-30-49.png)
    위 그림에서 IP주소 172.217.26.14이고, 도메인 이름은 google.com 입니다.

-   **DNS**: DNS는 Domain Name System의 줄임말로, 호스트의 도메인 이름을 IP 주소로 변환하거나 반대의 경우를 수행할 수 있도록 개발된 데이터베이스 시스템입니다. 만약 브라우저의 검색창에 naver.com을 입력한다면, 이 요청은 DNS에서 IP 주소(125.209.222.142)를 찾습니다. 그리고 이 IP 주소에 해당하는 웹 서버로 요청을 전달하여 클라이언트와 서버가 통신할 수 있도록 합니다.
