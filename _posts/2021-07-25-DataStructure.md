---
title: '자료구조란?'
excerpt: 'stack, queue, tree, bfs, dfs'

categories:
    - TIL
tags:
    - TIL
    - JavaScript
    - DataStructure
toc: true
toc_sticky: true
last_modified_at: 2021-07-25
---

# 자료구조

## 자료구조란?

-   자료구조란 여러 데이터들의 묶음을 저장하고, 사용하는 방법을 정의한 것입니다.
-   무수한 상황에서 데이터를 효율적으로 다룰 수 있는 방법을 모두 모아 잘죠구조라는 이름을 붙였습니다.
-   대부분의 자료구조는 특정한 상황에 놓인 문제를 해결하는 데에 특화되어 있습니다. 따라서 많은 자료구조를 알아두면, 어떠한 상황이 닥쳤을 때 적합한 자료구조를 빠르고 정확하게 적용하여 문제를 해결할 수 있습니다.

## 데이터란?

데이터는 문자, 숫자, 소리, 그림, 영상 등 실생활을 구성하고 있는 모든 값입니다. 그러나 데이터는 그 자체만으로 어떤 정보를 가지기 힘듭니다. 예를 들어 나이라는 데이터만 알고 있다면, 사람의 나이인지, 강아지의 나이인지, 나무의 나이인지 알 수 없습니다. 이처럼 데이터는 분석하고 정리하여 활용해야만 의미를 가질 수 있습니다.
데이터를 정해진 규칙없이 저장하고나, 하나의 구조로만 정리하고 활용하는 것보다 데이터를 체계적으로 정리하여 저장해두는 게, 데이터를 활용하는 데 있어 훨씬 유리합니다.

## Stack

![](https://images.velog.io/images/blackdavil01/post/c47c3897-d1f8-4e81-b63e-67c697a49896/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-25%2014-33-57.png)
Stack은 데이터를 순서대로 쌓는 자료구조입니다. Stack은 입력과 출력이 하나의 방향으로 이루어지는 제한적 접근에 있어 가장 먼저 들어가면 가장 나중에 나올 수 있습니다. 이런 Stack자료구조의 정책을 LIFO(Last In First Out) 혹은 FILO(First In Last Out)이라고 합니다.

## Queue

![](https://images.velog.io/images/blackdavil01/post/8e200afc-0dc5-4088-b0b9-780304f05dd1/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-25%2014-36-01.png)
Queue는 자료구조 Stack와 반대되는 개념으로, 먼저 들어간 데이터가 먼저 나오는 FIFO(First In First Out) 혹은 LILO(Last In Last Out) 특징을 가지고 있습니다.

## Graph

![](https://images.velog.io/images/blackdavil01/post/7c135d9a-f596-4e75-bf6b-88363bed3f58/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-25%2014-40-08.png)
그래프라고 하면 보통 수학 수업때 배우던 그래프를 떠올리게 되지만 컴퓨터 공학에서 이야기 하는 자료구조 그래프는 전혀 다른 모습을 가지고 있습니다.
그래프는 여러개의 점들이 서로 복잡하게 연결되어 있는 관계를 표현한 자료구조입니다. 직접적인 관계가 있는 경우 두 점 사이를 이어주는 선이 있습니다. 간접적인 관계라면 몇 개의 점과 선에 걸쳐 이어집니다. 하나의 점을 그래프에서는 정점(vertex)이라고 표현하고, 하나의 선은 간선(edge)이라고 합니다.

### 그래프 용어

-   **무(방)향 그래프(undirected graph):** 부산과 서울은 왔다갔다하는 것을 예로 들자면 무방향그래프는 서울에서 부산으로 갈 수도 있고, 부산에서 서울로도 갈 수 있지만, 단방향(directed)그래프로 구현된다면 부산에서 서울로 가는 것은 불가능합니다(혹은 그 반대) 즉, 무(방)향그래프는 왕복이 가능하고 단방향그래프는 편도로만 가능합니다.

-   **진입차수(in-degree)/진출차수(out-degree):** 한 정점에 진입(들어오는 간선)하고 진출(나가는 간선)하는 간선이 몇개인지를 나타냅니다.

-   **인접(adjacency):** 두 정점간에 간선이 직접 이어져 있다면 이 두 정점은 인접한 정점입니다.

-   **자기 루프(self loop):** 정점에서 진출하는 간선이 곧바로 자기 자신에게 진입하는 경우 자기 루프를 가졌다 라고 표현합니다. 다른 정점을 거치지 않는다는 것이 특징입니다.

-   **사이클(cycle):** 한 정점에서 출발하여 다시 해당 정점으로 돌아갈 수 있다면 사이클이 있다고 표현합니다.

### 그래프의 표현 방식(1): 인접 행렬

![](https://images.velog.io/images/blackdavil01/post/359963ea-9675-4b3a-af7e-e8572da57761/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-25%2014-49-01.png)

```js
// 인접행렬를 코드로 나타내면
const matrix = [
    [0, 0, 0, 0, 0][(0, 0, 0, 0, 0)][(0, 0, 0, 0, 0)][(0, 0, 0, 0, 0)][(0, 0, 0, 0, 0)],
];
```

인접 행렬은 서로 다른 정점들이 인접한 상태인지를 표시한 행렬로 2차원 배열의 형태로 나타냅니다. 만약 A라는 정점과 B라는 정점이 이어져 있다면 1(true), 이어져 있지 않다면 0(false)으로 표시한 일종의 표입니다.

**인접 행렬은 언제 사용할까?**

-   한 개의 큰 표와 같은 모습을 한 인접 행렬은 두 정점 사이에 관계가 있는지, 없는지 확인하기에 용이합니다.
    (예를 들어 A에서 B로 진출하는 간선이 있는지 파악하기 위해선 0번쨰 줄의 1번째 열에 어떤 값이 저장되어 있는지 바로 확인할 수 있습니다.
-   가장 빠른 경로를 찾고자 할 때 주로 사용됩니다.

### 그래프의 표현 방식(2): 인접 리스트

![](https://images.velog.io/images/blackdavil01/post/536f41e0-0ef3-41c1-bdac-f12c43a3160e/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-25%2014-52-04.png)

```js
// 인접 리스트를 코드로 나타내면
const adjList =
{
0: [1],
1: [0],
2: [3],
3: [2,4,5],
4: [3]
5: [3]
}
```

인접 리스트는 각 정점이 어떤 정점과 인접한지를 리스트의 형태로 표현합니다. 각 정점마다 하나의 리스트를 가지고 있으며, 이 리스트는 자신과 인접한 다른 정점을 담고 있습니다.

**인접 리스트는 언제 사용할까?**

-   메모리를 효율적으로 사용하고 싶을 때 인접 리스트를 사용합니다.
    (인접 행렬은 연결 가능한 모든 경우의 수를 저장하기 때문에 상대적으로 메모리를 많이 차지합니다.)

## Tree

자료구조 Tree는 이름 그대로 나무의 형태를 가지고 있습니다. 그래프의 여러 구조중 무방향그래프의 한 구조로, 하나의 뿌리로부터 가지고 사방으로 뻗은 형태가 나무와 닮아 있다고 해서 트리 구조라고 부릅니다.
데이터를 순차적으로 나열시킨 선형 구조가 아니라, 하나의 데이터 뒤에 여러 개의 데이터가 존재할 수 있는 비선형 구조입니다. 트리 구조는 계층적으로 표현이 되고, 아래로만 뻗어나가기 때문에 사이클이 없습니다.
![](https://images.velog.io/images/blackdavil01/post/24e39357-932d-4d2f-92fe-e28a2a854ad2/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-25%2015-04-56.png)
트리 구조는 루트(Root)라는 하나의 꼭짓점 데이터를 시작으로 여러 개의 데이터를 간선(edge)로 연결합니다. 각 데이터를 노드(Node)라고 하며, 두 개의 노드가 상하계층으로 연결되면 부모/자식 관계를 가집니다.

### 용어정리

-   노드(Node): 트리 구조를 이루는 모든 개별 데이터
-   루트(Root): 트리 구조의 시작점이 되는 노드
-   부모 노드(Parent node): 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 가까운 노드
-   자식 노드(Child node): 두 노드가 상하관계로 연결되어 있을 때 상대적으로 루트에서 먼 노드
-   리프(Leaf): 트리 구조의 끝지점이고, 자식 노드가 없는 노드

### Binary Search Tree(이진 탐색 트리)

트리 구조는 편리한 구조를 전시하는 것 외에 효율적인 탐색을 위해 사용하기도 합니다.
많은 트리의 모습 중, 가장 간단하고 많이 사용하는 이진 트리(binary tree)와 이진 탐색 트리(binary search tree)가 있습니다.
먼저, 이진트리(Binary tree)는 자식 노드가 최대 두 개인 노드들로 구성된 트리 입니다. 이 두개의 자식 노드는 왼쪽 자식 노드와 오른쪽 자식 노드로 나눌 수 있습니다.
![](https://images.velog.io/images/blackdavil01/post/b3da8c42-05d8-479c-b80e-18fdd9b3d42e/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7,%202021-07-25%2015-15-15.png)
이진 트리는 자료의 삽입, 삭제 방법에 따라 정 이진 트리(Full binary tree), 완전 이진 트리(Complete binary tree), 포화 이진 트리(Perfect binary tree)로 나뉩니다.

-   정 이진 트리: 각 노드가 0개 혹은 2개의 자식 노드를 갖습니다.
-   포화 이진 트리: 정 이진 트리이면서 완전 이진 트리인 경우입니다. 모든 리프 노드의 레벨이 동일하고 모든 레벨이 가득 채워져 있는 트리입니다.
-   완전 이진 트리: 마지막 레벨을 제외한 모든 노드가 가득 차 있어야 하고, 마지막 레벨의 노드는 전부 차 있지 않아도 되지만 왼쪽이 채워져야 합니다.

### Binary Search Tree(이진 탐색 트리)

이진 탐색 트리는 모든 왼쪽 자식의 값이 루트나 부모보다 작고, 모든 오른쪽 자식의 값이 루트나 부모보다 큰 값을 가지는 특징이 있습니다.
이진 탐색 트리는 균형 잡힌 트리가 아닐 때, 입력되는 값의 순서에 따라 한쪽으로 노드들이 몰리게 될 수 있습니다. 균형이 잡히지 않은 트리는 탐색하는 데 시간이 더 걸리는 경우도 있기 때문에 해결해야할 문제입니다. 이 문제를 해결하기 위해 삽입과 삭제마다 트리의 구조를 재조정하는 과정을 거치는 알고리즘을 추가할 수 있습니다.

## BFS(Breadth-First Search)/DFS(Depth-First Search)

![](https://images.velog.io/images/blackdavil01/post/2fd53577-e74a-4696-8a72-eb93d9f0c0d9/img.gif)
**BFS란**
최대한 넓게 이동한 다음, 더 이상 갈 수 없을 때 아래로 이동합니다.
루트 노드(혹은 다른 임의의 노드)에서 시작해서 인접한 노드를 먼저 탐색하는 방법으로, 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법입니다.
주로 두 노드 사이의 최단 경로를 찾고 싶을 때 이 방법을 선택합니다.
![](https://images.velog.io/images/blackdavil01/post/07c0d210-9d8a-4629-83b6-38accfd04328/12.gif)
**DFS란**
최대한 깊이 내려간 뒤, 더이상 깊이 갈 곳이 없을 경우 옆으로 이동
루트 노드(혹은 다른 임의의 노드)에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방법을 말합니다.

-   주로 모든 노드를 방문하고자 하는 경우에 이 방법을 사용합니다.
-   DFS가 BFS보다 좀 더 간단합니다.
-   검색 속도 자체는 BFS가 조금 더 빠릅니다.

**BFS/DFS 비교**

| DFS(깊이우선탐색)                                 | BFS(너비우선탐색)                       |
| ------------------------------------------------- | --------------------------------------- |
| 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색 | 현재 정점에 연결된 가까운 점들부터 탐색 |
| 스택 또는 재귀함수로 구현                         | 큐를 이용해서 구현                      |
